<!DOCTYPE html>
<html>
<head>
  <title>2D Tank Battle – Directional Gun Edition</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #111;
      font-family: Arial, sans-serif;
    }
    #gameContainer {
      position: relative;
    }
    canvas {
      background: #3a5a33;
      border: 2px solid #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 18px;
      text-shadow: 1px 1px 3px #000;
    }
    .health-bar {
      width: 200px;
      height: 20px;
      background: #555;
      border: 2px solid #fff;
      margin-bottom: 8px;
    }
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ff00, #008800);
    }
    #gunUI {
      margin-top: 10px;
    }
    #gameOver {
      position: absolute;
      top: 0;
      left: 0;
      width: 800px;
      height: 600px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 48px;
      display: flex;
      justify-content: center;
      align-items: center;
      display: none;
      z-index: 2;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
      <div>Player</div>
      <div class="health-bar">
         <div id="playerHealthBar" class="health-fill" style="width: 100%;"></div>
      </div>
      <div>Enemy</div>
      <div class="health-bar">
         <div id="enemyHealthBar" class="health-fill" style="width: 100%;"></div>
      </div>
      <div id="gunUI">Gun Direction: 0°</div>
    </div>
    <div id="gameOver">Game Over<br><small>Refresh to restart</small></div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let gameOver = false;

    // Explosion particles for bullet impacts.
    let explosionParticles = [];
    function createExplosion(x, y) {
      const particleCount = 15;
      for (let i = 0; i < particleCount; i++) {
        explosionParticles.push({
          x: x,
          y: y,
          radius: Math.random() * 3 + 2,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          alpha: 1
        });
      }
    }
    function updateExplosions() {
      for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const p = explosionParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.02;
        if (p.alpha <= 0) explosionParticles.splice(i, 1);
      }
    }
    function drawExplosions() {
      explosionParticles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#ffaa00";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // Draw ground with a grid.
    function drawGround() {
      ctx.fillStyle = "#3a5a33";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#4a7043";
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Utility: Draw a rounded rectangle.
    function roundRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }

    // Utility: Shade a hex color.
    function shadeColor(color, percent) {
      const f = parseInt(color.slice(1), 16),
            t = percent < 0 ? 0 : 255,
            p = percent < 0 ? percent * -1 : percent;
      const R = f >> 16, G = f >> 8 & 0x00FF, B = f & 0x0000FF;
      return "#" + (0x1000000 + (Math.round((t-R)*p/100)+R)*0x10000 +
            (Math.round((t-G)*p/100)+G)*0x100 +
            (Math.round((t-B)*p/100)+B)).toString(16).slice(1);
    }

    // Obstacle class – supports "block" and "tree" types.
    class Obstacle {
      constructor(x, y, width, height, type = "block") {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = type;
      }
      draw() {
        if (this.type === "tree") {
          // Draw tree: trunk and canopy.
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(this.x + this.width/2 - 5, this.y + this.height - 20, 10, 20);
          ctx.fillStyle = "#228B22";
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + this.height - 30, 20, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Block obstacle.
          ctx.fillStyle = "#666";
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.strokeStyle = "#444";
          ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
      }
      collidesWith(x, y, w, h) {
        return x < this.x + this.width &&
               x + w > this.x &&
               y < this.y + this.height &&
               y + h > this.y;
      }
    }

    // Tank class: the angle controls both the body and turret direction.
    class Tank {
      constructor(x, y, color, isPlayer = false) {
        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 50;
        this.color = color;
        this.angle = 0;
        this.health = 100;
        // Only the player moves; the enemy is static.
        this.speed = isPlayer ? 3 : 0;
        this.bullets = [];
        this.shootCooldown = 0;
        this.isPlayer = isPlayer;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        ctx.rotate(this.angle);
        const bodyGrad = ctx.createLinearGradient(-this.width/2, 0, this.width/2, 0);
        bodyGrad.addColorStop(0, shadeColor(this.color, -20));
        bodyGrad.addColorStop(1, this.color);
        ctx.fillStyle = bodyGrad;
        roundRect(ctx, -this.width/2, -this.height/2, this.width, this.height, 8);
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 2;
        ctx.stroke();
        // Draw turret (gun) that aligns with the tank’s angle.
        ctx.fillStyle = "#999";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "#555";
        ctx.fillRect(-4, -30, 8, 25);
        ctx.strokeStyle = "#222";
        ctx.strokeRect(-4, -30, 8, 25);
        ctx.restore();

        // Draw bullets.
        this.bullets.forEach(b => {
          ctx.save();
          ctx.translate(b.x, b.y);
          ctx.rotate(b.angle);
          ctx.fillStyle = "#ff2222";
          ctx.fillRect(-3, -3, 6, 6);
          ctx.restore();
        });
      }
      shoot() {
        if (this.shootCooldown <= 0) {
          const barrelLength = 30;
          const fireAngle = this.angle;
          const startX = this.x + this.width/2 + Math.cos(fireAngle) * barrelLength;
          const startY = this.y + this.height/2 + Math.sin(fireAngle) * barrelLength;
          const bullet = {
            x: startX,
            y: startY,
            speed: 6,
            angle: fireAngle
          };
          this.bullets.push(bullet);
          this.shootCooldown = 30;
        }
      }
      update(obstacles) {
        this.shootCooldown = Math.max(0, this.shootCooldown - 1);
        // Update bullets and remove those that hit obstacles or go off-screen.
        this.bullets = this.bullets.filter(b => {
          b.x += Math.cos(b.angle) * b.speed;
          b.y += Math.sin(b.angle) * b.speed;
          for (let obstacle of obstacles) {
            if (obstacle.collidesWith(b.x - 3, b.y - 3, 6, 6)) {
              createExplosion(b.x, b.y);
              return false;
            }
          }
          return (b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height);
        });
      }
      move(dx, dy, obstacles) {
        let newX = this.x + dx;
        let newY = this.y + dy;
        // Check for collisions with obstacles.
        for (let obstacle of obstacles) {
          if (obstacle.collidesWith(newX, newY, this.width, this.height)) {
            return;
          }
        }
        if (newX < 0 || newX + this.width > canvas.width ||
            newY < 0 || newY + this.height > canvas.height) return;
        this.x = newX;
        this.y = newY;
      }
    }

    // Create player and enemy tanks.
    const player = new Tank(100, 300, "#006600", true);
    const enemy = new Tank(600, 300, "#660000", false);

    // Keyboard controls.
    const keys = {};
    document.addEventListener("keydown", e => {
      keys[e.key] = true;
      if (e.key === " ") {
        if (player.shootCooldown <= 0) player.shoot();
      }
    });
    document.addEventListener("keyup", e => {
      keys[e.key] = false;
    });

    // Define obstacles (blocks and trees) for a varied battlefield.
    const obstacles = [
      new Obstacle(200, 150, 100, 50, "block"),
      new Obstacle(350, 250, 120, 60, "block"),
      new Obstacle(500, 100, 80, 80, "block"),
      new Obstacle(150, 400, 150, 50, "block"),
      new Obstacle(600, 350, 100, 50, "block"),
      new Obstacle(100, 50, 50, 80, "tree"),
      new Obstacle(700, 50, 50, 80, "tree"),
      new Obstacle(50, 500, 50, 80, "tree"),
      new Obstacle(750, 500, 50, 80, "tree")
    ];

    // Main game loop.
    function gameLoop() {
      if (gameOver) return;
      drawGround();

      // Calculate movement vector based on arrow keys.
      let moveX = 0, moveY = 0;
      if (keys["ArrowUp"])    moveY -= player.speed;
      if (keys["ArrowDown"])  moveY += player.speed;
      if (keys["ArrowLeft"])  moveX -= player.speed;
      if (keys["ArrowRight"]) moveX += player.speed;
      
      // If moving, update the tank’s angle to match the direction.
      if (moveX !== 0 || moveY !== 0) {
        player.angle = Math.atan2(moveY, moveX);
      }
      
      player.move(moveX, moveY, obstacles);

      // Update the gun UI element (angle in degrees).
      let gunDegrees = Math.round((player.angle * 180 / Math.PI + 360) % 360);
      document.getElementById("gunUI").textContent = "Gun Direction: " + gunDegrees + "°";

      // Update tanks.
      player.update(obstacles);
      enemy.update(obstacles);

      // Check for bullet collisions.
      player.bullets.forEach(b => {
        if (Math.abs(b.x - (enemy.x + enemy.width/2)) < enemy.width/2 &&
            Math.abs(b.y - (enemy.y + enemy.height/2)) < enemy.height/2) {
          enemy.health -= 10;
          createExplosion(b.x, b.y);
          b.x = -100;
        }
      });
      enemy.bullets.forEach(b => {
        if (Math.abs(b.x - (player.x + player.width/2)) < player.width/2 &&
            Math.abs(b.y - (player.y + player.height/2)) < player.height/2) {
          player.health -= 10;
          createExplosion(b.x, b.y);
          b.x = -100;
        }
      });

      updateExplosions();

      // Draw obstacles, tanks, and explosions.
      obstacles.forEach(o => o.draw());
      player.draw();
      enemy.draw();
      drawExplosions();

      // Update UI health bars.
      document.getElementById("playerHealthBar").style.width = Math.max(player.health, 0) + "%";
      document.getElementById("enemyHealthBar").style.width = Math.max(enemy.health, 0) + "%";

      // Check for game over.
      if (player.health <= 0 || enemy.health <= 0) {
        gameOver = true;
        document.getElementById("gameOver").style.display = "flex";
      } else {
        requestAnimationFrame(gameLoop);
      }
    }

    gameLoop();
  </script>
</body>
</html>
